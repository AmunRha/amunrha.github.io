---
title: "SEH & VEH in a security perspective"
draft: false
date: 2024-05-28
description: "Exception handlers are not something that we have not heard about before, it has been one of the basic ways to handle unforeseen errors within a program. In this blog post we will dive a bit deeper into exception handling techniques that could potentially be employed in an offensive security perspective."
categories:
  - Offensive Security
  - Malware Development
tags:
  - SEH
  - VEH
  - Exceptions
  - Malware
  - RedTeaming
  - Windows
tableOfContents: true
---

## Introduction

Exception handlers are not something that we have not heard about before, it has been one of the basic ways to handle unforeseen errors within a program. In this blog post we will dive a bit deeper into exception handling techniques that could potentially be employed in an offensive security perspective.

Before diving into this post, I am going to assume that you already are aware of what exceptions are in general, if not please refer to the below links to know more about them,

- [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/)
- [https://www.w3schools.com/cpp/cpp_exceptions.asp](https://www.w3schools.com/cpp/cpp_exceptions.asp)
- [https://wiki.osdev.org/Exceptions](https://wiki.osdev.org/Exceptions)

{{< alert error "Disclaimer" >}} The below blog post is only for educational and research purposes. Do not attempt to use it in any illegal or unethical circumstances. Please be responsible. {{< /alert >}}

## SEH - Structured Exception Handlers

We can assume that this exception handler is more or less the classic version of handling exceptions within the windows operating system until the new VEH was introduced.

The exception handler is fairly basic in terms of how it works regards to other handlers, there is a try block that wraps the unsafe code and an except block which handles a particular exception when generated.

In the below code as you can see, we can generate an exception by giving 0 as the second input, as division by zero is an exception generated by the system. This is wrapped within the `try` block and the filter code checks what sort of exception this is, in this case if it is `EXCEPTION_INT_DIVIDE_BY_ZERO` we proceed to handling the exception wrapped within the `except` block.

```cpp
int main()
{
    __try
    {
        int inp1 = 0, inp2 = 0;
        printf("Enter your first input: ");
        scanf_s("%d", &inp1);
        printf("Enter your second input: ");
        scanf_s("%d", &inp2);
        int result = inp1 / inp2;
        printf("Result: %d", result);
    }
    __except ((_exception_code() == EXCEPTION_INT_DIVIDE_BY_ZERO || _exception_code() == EXCEPTION_FLT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        printf("Exception triggered:  EXCEPTION_FLT_DIVIDE_BY_ZERO\n");
    }

    return 0;
}
```

{{< img src="Untitled.png" >}}

While reverse engineering it is quite easy to find the exception blocks if you know where you are looking at. I wont go through all the details of all the structure here, but in a very generic sense there is one final structure that is necessary for us to retrieve back the filters and the handler code.

The structure `SCOPE_TABLE` is important to us because it contains where each individual exception occurs and the necessary details for it, the structure is defined as below,

```cpp
 typedef struct _SCOPE_TABLE {
     ULONG Count;
     struct
     {
         ULONG BeginAddress;
         ULONG EndAddress;
         ULONG HandlerAddress;
         ULONG JumpTarget;
     } ScopeRecord[1];
 } SCOPE_TABLE, *PSCOPE_TABLE;
```

The structure contains several members such as,

- `BeginAddress` : This contains the start of the block where the exception **might** occur wrapped using the `try` block.
- `EndAddress` : This contains end of the `try` block where the exception **might** occur.
- `HandlerAddress` : This points to the filter function which is wrapped inside the `except()` statement. This is the function that is responsible to find out what sort of exception it is supposed to handle like `EXCEPTION_ACCESS_VIOLATION` , etc.
- `JumpTarget` : This points to where the code responsible to handle the exception is located.

{{< alert info "Note" >}} All of the above are offsets and not pointers. {{< /alert >}}

In order to find this structure, we will need to traverse a couple other structures, we go through the following flow, and we will end up with a pointer to the `SCOPE_TABLE` . The structure, `RUNTIME_FUNCTION` → `UnwindData` → `ExceptionData` will provide us with the `SCOPE_TABLE`. 

There is a major difference between how SEH works in x64 vs x86. While SEH is stored in x86 within the stack, it is embedded within the PE structure as you see above in x64 binaries.

In a very generic sense you could assume that this starts straight from the compile time. The compiler generates all the necessary information about the exception, what type of exception, the location of the filter and the final code to handle it, etc. and puts them into the exception frame embedded inside the PE file. This is a better implementation than the x86 architecture since it avoids any sort of simple overwrite on the exception frame during runtime via any buffer overflow.

## VEH - Vectored Exception Handlers

This is the modern day implementation of exception handler routines within windows. These handlers work using the mechanism of callback functions. These callback functions are invoked whenever an exception occurs. The interesting thing is, all these callback functions are in a linked list of sort which is added during runtime by the binary. A callback can be registered anywhere within the program via the winAPI `AddVectoredExceptionHandler` . 

Something to note is, that VEH exception handlers are registered globally and not tied to a single function or single stack frame. Due to backwards compatibility, the system calls all the VEH handlers first, and if none of them executes the handler, it is passed down to the SEH. Also, VEH is implemented as a circularly linked list.

Now, back to topic, the winAPI is defined as follows,

```cpp
PVOID AddVectoredExceptionHandler(
  ULONG                       First,
  PVECTORED_EXCEPTION_HANDLER Handler
);
```

This winAPI takes two arguments, 

- The first argument defines if the handler function is supposed to be registered at the start of the linked list or at the end of the linked list. This tells the system which handler to call first.
- The second argument is the pointer to the callback function to be registered.

These handlers are essentially stored in a linked list, which is global to the whole process.

The callback function is defined as follows,

```cpp
PVECTORED_EXCEPTION_HANDLER PvectoredExceptionHandler;

LONG PvectoredExceptionHandler(
  [in] _EXCEPTION_POINTERS *ExceptionInfo
)
```

The first argument to the callback function is very important in this blog, as it contains all the necessary information we are about to use and take advantage of. 

The pointer to the structure in the first argument is defined as follows,

```cpp
typedef struct _EXCEPTION_POINTERS {
  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT          ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
```

The structure contains two major details,

- One is that the first pointer in the structure points to the details of the exception defined by the structure `EXCEPTION_RECORD` which we will come to in a minute.
- The second is that the second pointer points to the structure `CONTEXT` which contains all the details about the CPU context like the registers, the flags, etc. when the exception occurred.

Although not as important as `ContextRecord`, the structure `ExceptionRecord` is defined as follows,

```cpp
typedef struct _EXCEPTION_RECORD {
  DWORD                    ExceptionCode;
  DWORD                    ExceptionFlags;
  struct _EXCEPTION_RECORD *ExceptionRecord;
  PVOID                    ExceptionAddress;
  DWORD                    NumberParameters;
  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
```

The first element over here is what is mostly used in this blog, and it contains what sort of exception is generated, such as `STATUS_INTEGER_DIVISION_BY_ZERO` . 

The `ContextRecord` is important to us because it allows us to read and also write back the data into it which will directly get applied over the CPU once execution is resumed. This is due to the fact that when the exception handler completed its execution, depending on the return value the system will continue searching for the exception or continue the process execution.

When the system moves onto to continuing the process execution it invokes the `RtlRestoreContext` winAPI which restores the CPU state with the data that we overwrote it with. Since, this is done by the system security products usually do not detect such CPU state overwriting.

Now, moving onto a practical implementation on how VEH works, we can see in the below code which is quite similar in terms of how exceptions are generated using the division by zero error.

We register a handler named `myHandler()` which is going to be a global handler within the VEH exception list. This handler is responsible to check if the exception that occurred is the one we want.

```cpp
#define CALL_FIRST 1

LONG WINAPI myHandler(
    struct _EXCEPTION_POINTERS* ExceptionInfo
) {
    if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_INTEGER_DIVIDE_BY_ZERO || ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_FLOAT_DIVIDE_BY_ZERO) {
        printf("Exception triggered:  STATUS_INTEGER_DIVIDE_BY_ZERO\n");
    }
    return EXCEPTION_CONTINUE_EXECUTION;
}

int main()
{
    PVOID h1 = AddVectoredExceptionHandler(CALL_FIRST, myHandler);
    int inp1 = 0, inp2 = 0;
    printf("Enter your first input: ");
    scanf_s("%d", &inp1);
    printf("Enter your second input: ");
    scanf_s("%d", &inp2);
    int result = inp1 / inp2;
    printf("Result: %d", result);
    RemoveVectoredExceptionHandler(h1);
    return 0;
}
```

{{< img src="Untitled 1.png" >}}

VEH unlike SEH can be considered a runtime mechanism due to the fact that handlers are registered and removed during runtime anywhere in the process. 

## *minor* Control Flow Obfuscation - Anti-Analysis

This is the part where I show you how these exception handlers can be used for purposes to make life tiny bit more difficult while analyzing. Several malwares employ these techniques in order to perform, anti-debug or anti-disassembly tricks. In this section, I will show you a similar case.

After implementing the SEH code from above, opening it up in IDA provides us with the following graph view. Since the code was simple enough, we can clearly identify which part of this code is part of our filter, and handler. 

In the below screenshot, you can identify that the right side of the graph which is independent from the left side of it is the exception filter for that particular function. Whereas the lowest node in the right side of the graph is the exception handler used to handle the exception. The jmp statement above that defines a unconditional jump which usually makes disassemblers/decompilers behave abnormally.

{{< img src="Untitled 2.png" >}}

Although there is no such graph related tricks in VEH handlers, this is how the IDA shows VEH being used within the disassembly. As you can see, the handler is passed as an argument via the `rdx` register (second argument).

{{< img src="Untitled 3.png" >}}

{{< img src="Untitled 4.png" >}}

Although it might be simple for manual reverse engineering, this might be enough to thwart simple signature analysis checks in usual malwares. The concept is to split out the code just like the above to different code blocks, using SEH or VEH in order to execute them. Signature analysis usually gets defeated by such simple mechanisms.

To know more about how such an implementation could be leveraged, check out this write up that I made for a challenge I created for **bi0sCTF 2022.** Its a fairly easy windows malware challenge if you know the underlying concepts being used. Write up Link: [Bluelock - bi0sCTF 2022](https://amunrha.github.io/posts/bluelock_bi0sctf23/)

## Context Modification using VEH handlers

As mentioned previously, since we have access to the CPU’s context structure and also permission for read/write over it. We could easily modify the contents of the structure to serve our needs in multiple ways. If creative enough you could possibly combine this technique with a few others to completely bypass AV/EDR checks.

In this blog I will be mentioning about a couple techniques that can be used to used as anti-debug checks within your process and evasion techniques for security products.

### Hardware Breakpoint Check

Remember we have access to two things here,

1. Generate our own exception handler and register a handler for it
2. Receive the entire context of the process when that exception was hit

#### Hardware Breakpoints - Brief Explanation

Before diving in further, I shall just clear out the concept about hardware breakpoint, if you already know this feel free to skip to the next section in the blog, so here we go.

Typically there are 4 different hardware breakpoints used by the CPU in order keep track of where those breakpoints were set. And some information about it, such as break on read, write or execute or any combo of them. 

Hardware breakpoints are very different from software breakpoints because of a couple reasons.

1. Software breakpoints require you to insert a particular opcode whenever it is set, the `int 3` opcode. Although hardware breakpoints use the CPU in order to store the address of it, this does not modify the instructions within the memory unlike software breakpoints.

{{< alert info "Note" >}} Detection of this is very trivial. If you already did not know, a simple checksum of a block, or usage of other winAPIs, TIBs, PEBs, etc. could be used.  {{< /alert >}}

2. There can be many software breakpoints set for a process, but hardware breakpoints has a maximum limit of 4. This is due to the fact that it is being tracked using the CPU’s registers.

Below shown structure is the definition of the `CONTEXT` structure, you can see that the registers, Dr0, Dr1, Dr2, Dr3 are present. These are the registers which are used to track the hardware breakpoints.

```cpp
typedef struct _CONTEXT {
  // trimmed at the start
  .
  .
  .
  DWORD   ContextFlags;
  DWORD   MxCsr;
  WORD    SegCs;
  WORD    SegDs;
  WORD    SegEs;
  WORD    SegFs;
  WORD    SegGs;
  WORD    SegSs;
  DWORD   EFlags;
  DWORD64 Dr0; // Hardware Breakpoint 1
  DWORD64 Dr1; // Hardware Breakpoint 2
  DWORD64 Dr2; // Hardware Breakpoint 3
  DWORD64 Dr3; // Hardware Breakpoint 4
  DWORD64 Dr6;
  DWORD64 Dr7;
  DWORD64 Rax;
  DWORD64 Rcx;
  DWORD64 Rdx;
  DWORD64 Rbx;
  DWORD64 Rsp;
  DWORD64 Rbp;
  DWORD64 Rsi;
  DWORD64 Rdi;
  DWORD64 R8;
  DWORD64 R9;
  DWORD64 R10;
  DWORD64 R11;
  DWORD64 R12;
  DWORD64 R13;
  DWORD64 R14;
  DWORD64 R15;
  DWORD64 Rip;
  .
  .
  .
  // trimmed at the end
} CONTEXT, *PCONTEXT;
```

Due to the fact that hardware breakpoints are not typically checked within malware, and since the condition of break can also be read or write or execute. It is often use in unpacking malwares by reverse engineers and malware analysts.

Again, this sort of check can also be detected if you retrieve the context of the CPU. This is where we have our little trick. As you might already know several APIs are hooked and monitored to detect malicious properties of a process. This also includes winAPIs that could be used to retrieve the context of the CPU. To avoid this detection, we can leverage the exception handler routine. This allows us to safely read and detect if a hardware breakpoint is checked.

This is how you do that,

1. Step one is to generate an exception that can be handled, this can be anywhere within your code. One neat trick to add is to execute this code even before the start of the main function, like the TLS callback functions.
2. Step two, is to register the handler and handle the intentionally generated exception, this allows us to retrieve the context of the CPU. 
3. Step three, is to simply check the hardware breakpoint registers to see if they are in use. If they are you can either jump to exit or jump to an alternate code path that will throw off the analyst.

Lets see it in action here,

Step one, as mentioned before we can use an intentional exception generating scenario, like division by zero exception.

{{< img src="Untitled 5.png" >}}

Once that is implemented, you just need to register the handler and the callback function will contain the logic to check the contents of the context structure which you can see in the above screenshot.

As seen in the below screenshot, the handler function examines the registers of the context structure, namely the hardware breakpoint registers. If it is not `NULL` we can safely say there is a hardware breakpoint present in the address space of the process.

{{< img src="Untitled 6.png" >}}

And voila, using this simple check, we can see if the hardware breakpoints are set or not.

{{< img src="Untitled 7.png" >}}

As you can see in the below screenshot, if the hardware breakpoint is set, the process is able to detect it.

{{< img src="Untitled 8.png" >}}

### Jump where ? Direct RIP modification

Well, now that we have one modification of read, why not try writing into the context ? Since, we have access to the context structure, we can directly modify the contents of the RIP register to point wherever we want to, this means we can do indirect calls.

#### #1 - Jump anywhere

We can modify the RIP to jump to a location where we want using exception routines, it can be in middle of a function, start of a function, to a random shellcode, or even additional two bytes further in memory.

The first step to perform is to of course generate an exception, register a handler for it, and then retrieve the context.

Once that is out of the way, we can proceed to modifying RIP to be overwritten with the address of the function we want to call. Which otherwise will not get called.

In order to do that, we first need to know the address of the function that is loaded into the memory, if we know that we can safely jump to that location.

In the below piece of code, we find the offset to the function we want to call `myHiddenFunction()` which is `0x1000` . Then we retrieve the base address to the current process using the winAPI `GetModuleHandleA`  with the argument `NULL` . Once we know that, we add the offset of the function we want to call to the base address of our loaded process retrieving the address where the function was loaded in memory. We then proceed to overwriting the RIP with that address and continue the execution.

```cpp
ULONG64 myHiddenFunction_Offset = 0x1000;
HMODULE BaseAddress = GetModuleHandleA(NULL);
printf("[*] Base Address of our process: %#llx\n", (ULONG64)BaseAddress);
ULONG64 myHiddenFunctionAddress = (ULONG64)BaseAddress + myHiddenFunction_Offset;
printf("[*] Address of myHiddenFunction: %#llx\n", (ULONG64)myHiddenFunctionAddress);
ExceptionInfo->ContextRecord->Rip = (DWORD64)myHiddenFunctionAddress;
printf("[*] RIP modified to address of myHiddenFunction: %#llx\n", ExceptionInfo->ContextRecord->Rip);
```

As you can see in the below screenshot, the function is called although no direct calling of the function exists within the process.

{{< img src="Untitled 9.png" >}}

#### #2 - Code decryption during runtime

Code decryption is a necessary technique when devising offensive toolkit, usually to get a second stage out there, execute a shellcode, or perhaps even self-modifying pieces of art. Since we have access to RIP, we can easily perform this technique without tripping off a lot of wires.

In this section I will be using a sample shellcode found from here,  [MessageBox() shellcode](https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12). This sample shellcode executes a simple “Hello World” text within a message box. To perform this PoC, I encrypt the shellcode with the XOR key `0x13` . 

The idea is to use the exception `EXCEPTION_ACCESS_VIOLATION` which is generated whenever a invalid memory page or invalid access rights to a memory page is accessed. Since this shellcode is encrypted and stored in a global variable, I can easily generate the exception by simply casting the variable to a function call and calling it. This generates the exception we require because the global variable where the shellcode is stored in is not an executable memory region.

We can see that in the below screenshot.

{{< img src="Untitled 10.png" >}}

Now we modify the code to include two actions,

- Use the winAPI `VirtualProtect` to convert the global variable to an executable region using the parameter `PAGE_EXECUTE`
- Decrypt the shellcode using the XOR key `0x13` to produce a valid shellcode

You can see that the change in the below source produced the message box.

{{< img src="Untitled 11.png" >}}

To introduce a self modifying aspect here, we can encrypt bytes within the program using a key previously known. And once an exception is generated while trying to execute them (or we generate one ourselves), we can simply change the permission of the page to modify the shellcode using the RIP register, turn it back to executable and continue execution.

This can also be used to perform an advanced decryption method where the shellcode is decrypted and executed instruction by instruction. This can be done using the `STATUS_SINGLE_STEP` exception and the `STATUS_ACCESS_VIOLATION` exception. This is given as a challenge for the reader to perform ;)

#### #3 - Indirect syscall

Similar to the possibilities mentioned above, we can also modify the RIP to overwrite it with an address within the `ntdll.dll` library to perform an indirect syscall. 

One technique that is most commonly used within the malware domain is to use windows syscalls that is used to circumvent any hooking mechanism that might have been placed by the EDR within the general functions used in `ntdll.dll` . This is a common detection mechanism by an AV/EDR. 

Although, the usage of syscall works to bypass the detection, this results in another possible detection mechanism. Using syscalls within your own process without any redirection to another library is called direct syscall technique, whereas invoking syscalls from the library `ntdll.dll` of the process is called an indirect syscall technique.

When using syscalls within your own program, it can usually get caught either by simple signature, assuming you bypassed that, it can be caught be checking the origin of the syscall. Typical origin of the syscall takes place via legitimate sources like the `ntdll.dll` itself, but when that is not the case, it spins up a major red flag. This can be avoided using, well you guessed it ! Vectored Exception Handling !!

As mentioned in this blog post, [“Syscalls via Vectored Exception Handling”](https://redops.at/en/blog/syscalls-via-vectored-exception-handling), this technique also provides a very legitimate looking call stack when analyzing. This is helps in reducing the detection possibility by a huge margin.

To brief up a little bit, syscalls are a piece of instruction that is responsible to switch the context from user-mode to kernel-mode. Many of the functions that are used within any process finally is a single or a combination of syscalls that is usually found within the `ntdll.dll` . This dll contains the final wrapper for several of the system calls used. 

The syscalls are controlled by register RAX, which contains something called SSN, System Service Numbers. These are unique identifiers that are used to switch the control to the responsible code part within the kernel-land. SSN numbers in WIndows versions changes very frequently, it is very hard to keep track of them all. Although, there exists tools such as [Syswhispers3](https://github.com/klezVirus/SysWhispers3) and websites such as [Windows Syscall Table](https://j00ru.vexillium.org/syscalls/nt/64/) that can be used to retrieve the syscall for the particular version of windows you are using.

{{< img src="Untitled 12.png" >}}

VEH helps us by changing the control flow of the current process to the location that we want by allowing us to overwrite RIP, and also since it has access to literally the entire CPU context, we can use that in order to pass parameters. So combining both these ideas we could generate an exception and pass the necessary parameters within the registers in order to call the syscall that we want.

As mentioned in the above tagged blog post, the easiest way to do that is to leverage the exception `STATUS_ACCESS_VIOLATION` which is generated when invalid access to memory is performed. We can store the SSN number that we want to call, in this case `0x18` which corresponds to the syscall `NtAllocateVirtualMemory` , within a variable and then cast it to a function and call it. In essence this calls a function at the address `0x18` which obviously is not going to be a valid address. This in turn generates an exception of `STATUS_ACCESS_VIOLATION`. Now to pass the parameters to the function, we simply call the variable where the SSN is stored as any other function call and the context will contain the arguments you passed.

Once the exception is generated you can emulate the syscall instruction as how it is found within the `ntdll.dll` and change the control flow to the syscall address within the dll.

As mentioned above, you can see in the below screenshot that I am storing the SSN number into a variable, and then casting it to a function call and invoking it with the necessary arguments.

{{< img src="Untitled 13.png" >}}

Although, how do we find where the syscall is stored, what is the address of it ? The solution to this is basic signature matching (if you want stability) or offset calculation. Just like how we used offset calculation in changing to a function that we want to in one of the above examples, we can find the offset of the syscall opcode within the dll and then add the base address to it retrieving back the original address. 

This is not stable across versions, so a better method to deal with it is to perform signature matching against the dll to find the opcodes that we want, in this case the `syscalll; ret` opcode. 

In the below screenshot, we can notice that we retrieve back the address of the function `NtDrawText` as mentioned in the blog post, although we can retrieve any function, it does not matter as what we want to find is the address of the opcodes. Once the function address is retrieved, it is used as a starting point to perform signature matching against the given opcodes, `0xf, 0x5, 0xc3` . Once the syscall opcodes are found the address is sent back to be used.

{{< img src="Untitled 14.png" >}}

Since the invalid access will be handled within our function, the RIP register will contain the SSN we require to call as well, the RIP will be stored with the address of the syscall we retrieved, and the RAX register the SSN.

{{< img src="Untitled 15.png" >}}

After continuing the execution we can see that the syscall is executed and that the return value is a success as seen in the below screenshot.

{{< img src="Untitled 16.png" >}}

Please give the mentioned blogpost a read in order to dive deeper into how this concept works. This method can be used in combination of several other methods in order to evade defenses, creativity is the only limit here.

## Conclusion

In this blog post, I have tried to explain some of the concept used in SEH and VEH programming that I have came across while performing malware analysis, playing CTFs, etc. There definitely exists a lot more tricks than the mentioned and if one is creative enough, further more can be found out as this is still an uncharted territory. This hopefully serves as a blog post that touches some light on this subject and gives the reader something to take away. 

As a future work that I have not covered in this blog post are, how to use VEH as a debugger (used in cheatengine), using VEH to bypass protections and memory scanners, etc.

Thanks for reading this post, and please let me know your feedback through my contacts, any and all feedback helps ! Feel free to DM me if you would like to have further discussions on this topic too! 

Stay tuned for more and have a great day ! 

Contact: [Twitter](https://twitter.com/amun_rha) | [LinkedIn](https://linkedin.com/in/adhithyasureshk)

All the codes used in this post has been uploaded over here: [Link to Github](https://github.com/AmunRha/BlogMaterials/tree/main/SEH_VEH_in_Malwares)

## References

- [https://redops.at/en/blog/syscalls-via-vectored-exception-handling](https://redops.at/en/blog/syscalls-via-vectored-exception-handling)
- [https://revers.engineering/applied-re-exceptions/](https://revers.engineering/applied-re-exceptions/)
- [https://www.osronline.com/article.cfm^article=469.htm](https://www.osronline.com/article.cfm%5Earticle=469.htm)
- [https://limbioliong.wordpress.com/2022/01/09/understanding-windows-structured-exception-handling-part-1/](https://limbioliong.wordpress.com/2022/01/09/understanding-windows-structured-exception-handling-part-1/)
- [https://j00ru.vexillium.org/syscalls/nt/64/](https://j00ru.vexillium.org/syscalls/nt/64/)
- [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory)
- [https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record)
- [https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_REGISTRATION_RECORD.html](https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_REGISTRATION_RECORD.html)
- [https://github.com/tpn/winsdk-10/blob/master/Include/10.0.10240.0/shared/ntdef.h](https://github.com/tpn/winsdk-10/blob/master/Include/10.0.10240.0/shared/ntdef.h)
- [https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_pointers](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_pointers)
