<!DOCTYPE html>
<html lang="en-US" class="scroll-smooth dark">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>

<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SEH &amp; VEH in a security perspective</title>
<meta
  name="description"
  content="Exception handlers are not something that we have not heard about before, it has been one of the basic ways to handle unforeseen errors within a program. In this blog post we will dive a bit deeper into exception handling techniques that could potentially be employed in an offensive security perspective."
/>
<link rel="canonical" href="http://localhost:1313/posts/seh_veh_security_perspective/" />
<link rel="robots" href="/robots.txt" />

<link rel="icon" type="image/x-icon" href="/icons/japanese-gate.png" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>

<link rel="stylesheet" href="http://localhost:1313/css/app.css" /></head>

<body class="max-w-screen-md mx-auto">
  <div class="header">
    <header class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 py-12">
   


<div class="flex-none w-20 h-20 rounded-full overflow-hidden">
  <a href="http://localhost:1313/">
    <img
      srcset="/img/wolf_square_hu12218815234515754814.jpg 80w"
      src="/img/wolf_square.jpg"
      width="978"
      height="1214"
      alt="AmunRha&#39;s Blog"
    />
  </a>
</div>

  
  <div class="flex flex-col gap-5">
    <a href="http://localhost:1313/">
  
  <h1 id="site-title">AmunRha<span class="text-rose-500 hover:text-rose-400">'</span>s Blog</h1>
</a>
 
    <nav>
  <ul>
     
    
    <li>
      <a href="/" class="">
        About me
      </a>
      <span class="text-rose-500 hover:text-rose-400 text-lg">.</span>
    </li>
    
    <li>
      <a href="/posts" class="">
        Posts
      </a>
      <span class="text-rose-500 hover:text-rose-400 text-lg">.</span>
    </li>
    
    <li>
      <a href="/categories" class="">
        Categories
      </a>
      <span class="text-rose-500 hover:text-rose-400 text-lg">.</span>
    </li>
    
    <li>
      <a href="/tags" class="">
        Tags
      </a>
      <span class="text-rose-500 hover:text-rose-400 text-lg">.</span>
    </li>
    
    <li class="-mt-2 block lg:hidden"><button class="toggle-theme" aria-label="Toggle Theme" title="Toggle Theme" onclick="toggleTheme()">
  <span class="theme-icon light hidden dark:block"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg> </span>
  <span class="theme-icon dark block dark:hidden"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg> </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme === 'light') {
      setTheme('light');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script></li>
  </ul>
</nav>

  </div>
</header>

    <div class="lg:inline-block hidden">
      <button class="toggle-theme" aria-label="Toggle Theme" title="Toggle Theme" onclick="toggleTheme()">
  <span class="theme-icon light hidden dark:block"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg> </span>
  <span class="theme-icon dark block dark:hidden"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg> </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme === 'light') {
      setTheme('light');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script>
    </div>
  </div>

  <main id="content">

<article class="flex flex-col gap-10">
  <header class="flex flex-col gap-2">
    <h1 class="title-large">SEH &amp; VEH in a security perspective</h2>

    <div class="meta">
      
      <time datetime="2024-05-28 00:00:00 &#43;0000 UTC" title='Tue, May 28, 2024, 12:00 AM UTC'>
        28/05/2024 - Estimated reading time: 21 minutes
      </time>

       
       — 
        
          <a class="categories" href="/categories/offensive-security/" alt="Offensive Security">
            Offensive Security
          </a>
        
          <a class="categories" href="/categories/malware-development/" alt="Malware Development">
            Malware Development
          </a>
         
      
    </div>
  </header>

  
  <aside class="table-of-contents">
    <h2 class="title-small">Table of Contents</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#seh---structured-exception-handlers">SEH - Structured Exception Handlers</a></li>
    <li><a href="#veh---vectored-exception-handlers">VEH - Vectored Exception Handlers</a></li>
    <li><a href="#minor-control-flow-obfuscation---anti-analysis"><em>minor</em> Control Flow Obfuscation - Anti-Analysis</a></li>
    <li><a href="#context-modification-using-veh-handlers">Context Modification using VEH handlers</a>
      <ul>
        <li><a href="#hardware-breakpoint-check">Hardware Breakpoint Check</a>
          <ul>
            <li><a href="#hardware-breakpoints---brief-explanation">Hardware Breakpoints - Brief Explanation</a></li>
          </ul>
        </li>
        <li><a href="#jump-where--direct-rip-modification">Jump where ? Direct RIP modification</a>
          <ul>
            <li><a href="#1---jump-anywhere">#1 - Jump anywhere</a></li>
            <li><a href="#2---code-decryption-during-runtime">#2 - Code decryption during runtime</a></li>
            <li><a href="#3---indirect-syscall">#3 - Indirect syscall</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
  </aside>


  <section><h2 id="introduction">Introduction</h2>
<p>Exception handlers are not something that we have not heard about before, it has been one of the basic ways to handle unforeseen errors within a program. In this blog post we will dive a bit deeper into exception handling techniques that could potentially be employed in an offensive security perspective.</p>
<p>Before diving into this post, I am going to assume that you already are aware of what exceptions are in general, if not please refer to the below links to know more about them,</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/</a></li>
<li><a href="https://www.w3schools.com/cpp/cpp_exceptions.asp">https://www.w3schools.com/cpp/cpp_exceptions.asp</a></li>
<li><a href="https://wiki.osdev.org/Exceptions">https://wiki.osdev.org/Exceptions</a></li>
</ul>



<div class="alert-box error">
  
    <h1 class="alert-title">Disclaimer</h1>
  
  <p class="flex flex-row items-center gap-2">
    
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      class="alert-icon"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z"
      />
    </svg>
    
     The below blog post is only for educational and research purposes. Do not attempt to use it in any illegal or unethical circumstances. Please be responsible. 
  </p>
</div>

<h2 id="seh---structured-exception-handlers">SEH - Structured Exception Handlers</h2>
<p>We can assume that this exception handler is more or less the classic version of handling exceptions within the windows operating system until the new VEH was introduced.</p>
<p>The exception handler is fairly basic in terms of how it works regards to other handlers, there is a try block that wraps the unsafe code and an except block which handles a particular exception when generated.</p>
<p>In the below code as you can see, we can generate an exception by giving 0 as the second input, as division by zero is an exception generated by the system. This is wrapped within the <code>try</code> block and the filter code checks what sort of exception this is, in this case if it is <code>EXCEPTION_INT_DIVIDE_BY_ZERO</code> we proceed to handling the exception wrapped within the <code>except</code> block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">__try</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">int</span> inp1 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, inp2 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#f1fa8c">&#34;Enter your first input: &#34;</span>);
</span></span><span style="display:flex;"><span>        scanf_s(<span style="color:#f1fa8c">&#34;%d&#34;</span>, <span style="color:#ff79c6">&amp;</span>inp1);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#f1fa8c">&#34;Enter your second input: &#34;</span>);
</span></span><span style="display:flex;"><span>        scanf_s(<span style="color:#f1fa8c">&#34;%d&#34;</span>, <span style="color:#ff79c6">&amp;</span>inp2);
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">int</span> result <span style="color:#ff79c6">=</span> inp1 <span style="color:#ff79c6">/</span> inp2;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#f1fa8c">&#34;Result: %d&#34;</span>, result);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">__except</span> ((_exception_code() <span style="color:#ff79c6">==</span> EXCEPTION_INT_DIVIDE_BY_ZERO <span style="color:#ff79c6">||</span> _exception_code() <span style="color:#ff79c6">==</span> EXCEPTION_FLT_DIVIDE_BY_ZERO) <span style="color:#ff79c6">?</span> <span style="color:#8be9fd;font-style:italic">EXCEPTION_EXECUTE_HANDLER</span> : EXCEPTION_CONTINUE_SEARCH)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#f1fa8c">&#34;Exception triggered:  EXCEPTION_FLT_DIVIDE_BY_ZERO</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>




<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled.png"  width="1167" height="228" />
  
  
</figure>
<p>While reverse engineering it is quite easy to find the exception blocks if you know where you are looking at. I wont go through all the details of all the structure here, but in a very generic sense there is one final structure that is necessary for us to retrieve back the filters and the handler code.</p>
<p>The structure <code>SCOPE_TABLE</code> is important to us because it contains where each individual exception occurs and the necessary details for it, the structure is defined as below,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> <span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_SCOPE_TABLE</span> {
</span></span><span style="display:flex;"><span>     ULONG Count;
</span></span><span style="display:flex;"><span>     <span style="color:#ff79c6">struct</span>
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>         ULONG BeginAddress;
</span></span><span style="display:flex;"><span>         ULONG EndAddress;
</span></span><span style="display:flex;"><span>         ULONG HandlerAddress;
</span></span><span style="display:flex;"><span>         ULONG JumpTarget;
</span></span><span style="display:flex;"><span>     } ScopeRecord[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span> } SCOPE_TABLE, <span style="color:#ff79c6">*</span>PSCOPE_TABLE;
</span></span></code></pre></div><p>The structure contains several members such as,</p>
<ul>
<li><code>BeginAddress</code> : This contains the start of the block where the exception <strong>might</strong> occur wrapped using the <code>try</code> block.</li>
<li><code>EndAddress</code> : This contains end of the <code>try</code> block where the exception <strong>might</strong> occur.</li>
<li><code>HandlerAddress</code> : This points to the filter function which is wrapped inside the <code>except()</code> statement. This is the function that is responsible to find out what sort of exception it is supposed to handle like <code>EXCEPTION_ACCESS_VIOLATION</code> , etc.</li>
<li><code>JumpTarget</code> : This points to where the code responsible to handle the exception is located.</li>
</ul>



<div class="alert-box info">
  
    <h1 class="alert-title">Note</h1>
  
  <p class="flex flex-row items-center gap-2">
    
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      class="alert-icon"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z"
      />
    </svg>
    
     All of the above are offsets and not pointers. 
  </p>
</div>

<p>In order to find this structure, we will need to traverse a couple other structures, we go through the following flow, and we will end up with a pointer to the <code>SCOPE_TABLE</code> . The structure, <code>RUNTIME_FUNCTION</code> → <code>UnwindData</code> → <code>ExceptionData</code> will provide us with the <code>SCOPE_TABLE</code>.</p>
<p>There is a major difference between how SEH works in x64 vs x86. While SEH is stored in x86 within the stack, it is embedded within the PE structure as you see above in x64 binaries.</p>
<p>In a very generic sense you could assume that this starts straight from the compile time. The compiler generates all the necessary information about the exception, what type of exception, the location of the filter and the final code to handle it, etc. and puts them into the exception frame embedded inside the PE file. This is a better implementation than the x86 architecture since it avoids any sort of simple overwrite on the exception frame during runtime via any buffer overflow.</p>
<h2 id="veh---vectored-exception-handlers">VEH - Vectored Exception Handlers</h2>
<p>This is the modern day implementation of exception handler routines within windows. These handlers work using the mechanism of callback functions. These callback functions are invoked whenever an exception occurs. The interesting thing is, all these callback functions are in a linked list of sort which is added during runtime by the binary. A callback can be registered anywhere within the program via the winAPI <code>AddVectoredExceptionHandler</code> .</p>
<p>Something to note is, that VEH exception handlers are registered globally and not tied to a single function or single stack frame. Due to backwards compatibility, the system calls all the VEH handlers first, and if none of them executes the handler, it is passed down to the SEH. Also, VEH is implemented as a circularly linked list.</p>
<p>Now, back to topic, the winAPI is defined as follows,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PVOID <span style="color:#50fa7b">AddVectoredExceptionHandler</span>(
</span></span><span style="display:flex;"><span>  ULONG                       First,
</span></span><span style="display:flex;"><span>  PVECTORED_EXCEPTION_HANDLER Handler
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>This winAPI takes two arguments,</p>
<ul>
<li>The first argument defines if the handler function is supposed to be registered at the start of the linked list or at the end of the linked list. This tells the system which handler to call first.</li>
<li>The second argument is the pointer to the callback function to be registered.</li>
</ul>
<p>These handlers are essentially stored in a linked list, which is global to the whole process.</p>
<p>The callback function is defined as follows,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PVECTORED_EXCEPTION_HANDLER PvectoredExceptionHandler;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LONG PvectoredExceptionHandler(
</span></span><span style="display:flex;"><span>  [in] _EXCEPTION_POINTERS <span style="color:#ff79c6">*</span>ExceptionInfo
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>The first argument to the callback function is very important in this blog, as it contains all the necessary information we are about to use and take advantage of.</p>
<p>The pointer to the structure in the first argument is defined as follows,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_EXCEPTION_POINTERS</span> {
</span></span><span style="display:flex;"><span>  PEXCEPTION_RECORD ExceptionRecord;
</span></span><span style="display:flex;"><span>  PCONTEXT          ContextRecord;
</span></span><span style="display:flex;"><span>} EXCEPTION_POINTERS, <span style="color:#ff79c6">*</span>PEXCEPTION_POINTERS;
</span></span></code></pre></div><p>The structure contains two major details,</p>
<ul>
<li>One is that the first pointer in the structure points to the details of the exception defined by the structure <code>EXCEPTION_RECORD</code> which we will come to in a minute.</li>
<li>The second is that the second pointer points to the structure <code>CONTEXT</code> which contains all the details about the CPU context like the registers, the flags, etc. when the exception occurred.</li>
</ul>
<p>Although not as important as <code>ContextRecord</code>, the structure <code>ExceptionRecord</code> is defined as follows,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_EXCEPTION_RECORD</span> {
</span></span><span style="display:flex;"><span>  DWORD                    ExceptionCode;
</span></span><span style="display:flex;"><span>  DWORD                    ExceptionFlags;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_EXCEPTION_RECORD</span> <span style="color:#ff79c6">*</span>ExceptionRecord;
</span></span><span style="display:flex;"><span>  PVOID                    ExceptionAddress;
</span></span><span style="display:flex;"><span>  DWORD                    NumberParameters;
</span></span><span style="display:flex;"><span>  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
</span></span><span style="display:flex;"><span>} EXCEPTION_RECORD;
</span></span></code></pre></div><p>The first element over here is what is mostly used in this blog, and it contains what sort of exception is generated, such as <code>STATUS_INTEGER_DIVISION_BY_ZERO</code> .</p>
<p>The <code>ContextRecord</code> is important to us because it allows us to read and also write back the data into it which will directly get applied over the CPU once execution is resumed. This is due to the fact that when the exception handler completed its execution, depending on the return value the system will continue searching for the exception or continue the process execution.</p>
<p>When the system moves onto to continuing the process execution it invokes the <code>RtlRestoreContext</code> winAPI which restores the CPU state with the data that we overwrote it with. Since, this is done by the system security products usually do not detect such CPU state overwriting.</p>
<p>Now, moving onto a practical implementation on how VEH works, we can see in the below code which is quite similar in terms of how exceptions are generated using the division by zero error.</p>
<p>We register a handler named <code>myHandler()</code> which is going to be a global handler within the VEH exception list. This handler is responsible to check if the exception that occurred is the one we want.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define CALL_FIRST 1
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span>LONG WINAPI <span style="color:#50fa7b">myHandler</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_EXCEPTION_POINTERS</span><span style="color:#ff79c6">*</span> ExceptionInfo
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (ExceptionInfo<span style="color:#ff79c6">-&gt;</span>ExceptionRecord<span style="color:#ff79c6">-&gt;</span>ExceptionCode <span style="color:#ff79c6">==</span> STATUS_INTEGER_DIVIDE_BY_ZERO <span style="color:#ff79c6">||</span> ExceptionInfo<span style="color:#ff79c6">-&gt;</span>ExceptionRecord<span style="color:#ff79c6">-&gt;</span>ExceptionCode <span style="color:#ff79c6">==</span> STATUS_FLOAT_DIVIDE_BY_ZERO) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#f1fa8c">&#34;Exception triggered:  STATUS_INTEGER_DIVIDE_BY_ZERO</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> EXCEPTION_CONTINUE_EXECUTION;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PVOID h1 <span style="color:#ff79c6">=</span> AddVectoredExceptionHandler(CALL_FIRST, myHandler);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> inp1 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, inp2 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#f1fa8c">&#34;Enter your first input: &#34;</span>);
</span></span><span style="display:flex;"><span>    scanf_s(<span style="color:#f1fa8c">&#34;%d&#34;</span>, <span style="color:#ff79c6">&amp;</span>inp1);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#f1fa8c">&#34;Enter your second input: &#34;</span>);
</span></span><span style="display:flex;"><span>    scanf_s(<span style="color:#f1fa8c">&#34;%d&#34;</span>, <span style="color:#ff79c6">&amp;</span>inp2);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> result <span style="color:#ff79c6">=</span> inp1 <span style="color:#ff79c6">/</span> inp2;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#f1fa8c">&#34;Result: %d&#34;</span>, result);
</span></span><span style="display:flex;"><span>    RemoveVectoredExceptionHandler(h1);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>




<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%201.png"  width="1166" height="220" />
  
  
</figure>
<p>VEH unlike SEH can be considered a runtime mechanism due to the fact that handlers are registered and removed during runtime anywhere in the process.</p>
<h2 id="minor-control-flow-obfuscation---anti-analysis"><em>minor</em> Control Flow Obfuscation - Anti-Analysis</h2>
<p>This is the part where I show you how these exception handlers can be used for purposes to make life tiny bit more difficult while analyzing. Several malwares employ these techniques in order to perform, anti-debug or anti-disassembly tricks. In this section, I will show you a similar case.</p>
<p>After implementing the SEH code from above, opening it up in IDA provides us with the following graph view. Since the code was simple enough, we can clearly identify which part of this code is part of our filter, and handler.</p>
<p>In the below screenshot, you can identify that the right side of the graph which is independent from the left side of it is the exception filter for that particular function. Whereas the lowest node in the right side of the graph is the exception handler used to handle the exception. The jmp statement above that defines a unconditional jump which usually makes disassemblers/decompilers behave abnormally.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%202.png"  width="779" height="684" />
  
  
</figure>
<p>Although there is no such graph related tricks in VEH handlers, this is how the IDA shows VEH being used within the disassembly. As you can see, the handler is passed as an argument via the <code>rdx</code> register (second argument).</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%203.png"  width="441" height="561" />
  
  
</figure>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%204.png"  width="555" height="544" />
  
  
</figure>
<p>Although it might be simple for manual reverse engineering, this might be enough to thwart simple signature analysis checks in usual malwares. The concept is to split out the code just like the above to different code blocks, using SEH or VEH in order to execute them. Signature analysis usually gets defeated by such simple mechanisms.</p>
<p>To know more about how such an implementation could be leveraged, check out this write up that I made for a challenge I created for <strong>bi0sCTF 2022.</strong> Its a fairly easy windows malware challenge if you know the underlying concepts being used. Write up Link: <a href="https://amunrha.github.io/posts/bluelock_bi0sctf23/">Bluelock - bi0sCTF 2022</a></p>
<h2 id="context-modification-using-veh-handlers">Context Modification using VEH handlers</h2>
<p>As mentioned previously, since we have access to the CPU’s context structure and also permission for read/write over it. We could easily modify the contents of the structure to serve our needs in multiple ways. If creative enough you could possibly combine this technique with a few others to completely bypass AV/EDR checks.</p>
<p>In this blog I will be mentioning about a couple techniques that can be used to used as anti-debug checks within your process and evasion techniques for security products.</p>
<h3 id="hardware-breakpoint-check">Hardware Breakpoint Check</h3>
<p>Remember we have access to two things here,</p>
<ol>
<li>Generate our own exception handler and register a handler for it</li>
<li>Receive the entire context of the process when that exception was hit</li>
</ol>
<h4 id="hardware-breakpoints---brief-explanation">Hardware Breakpoints - Brief Explanation</h4>
<p>Before diving in further, I shall just clear out the concept about hardware breakpoint, if you already know this feel free to skip to the next section in the blog, so here we go.</p>
<p>Typically there are 4 different hardware breakpoints used by the CPU in order keep track of where those breakpoints were set. And some information about it, such as break on read, write or execute or any combo of them.</p>
<p>Hardware breakpoints are very different from software breakpoints because of a couple reasons.</p>
<ol>
<li>Software breakpoints require you to insert a particular opcode whenever it is set, the <code>int 3</code> opcode. Although hardware breakpoints use the CPU in order to store the address of it, this does not modify the instructions within the memory unlike software breakpoints.</li>
</ol>



<div class="alert-box info">
  
    <h1 class="alert-title">Note</h1>
  
  <p class="flex flex-row items-center gap-2">
    
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      class="alert-icon"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z"
      />
    </svg>
    
     Detection of this is very trivial. If you already did not know, a simple checksum of a block, or usage of other winAPIs, TIBs, PEBs, etc. could be used.  
  </p>
</div>

<ol start="2">
<li>There can be many software breakpoints set for a process, but hardware breakpoints has a maximum limit of 4. This is due to the fact that it is being tracked using the CPU’s registers.</li>
</ol>
<p>Below shown structure is the definition of the <code>CONTEXT</code> structure, you can see that the registers, Dr0, Dr1, Dr2, Dr3 are present. These are the registers which are used to track the hardware breakpoints.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_CONTEXT</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// trimmed at the start
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  .
</span></span><span style="display:flex;"><span>  .
</span></span><span style="display:flex;"><span>  .
</span></span><span style="display:flex;"><span>  DWORD   ContextFlags;
</span></span><span style="display:flex;"><span>  DWORD   MxCsr;
</span></span><span style="display:flex;"><span>  WORD    SegCs;
</span></span><span style="display:flex;"><span>  WORD    SegDs;
</span></span><span style="display:flex;"><span>  WORD    SegEs;
</span></span><span style="display:flex;"><span>  WORD    SegFs;
</span></span><span style="display:flex;"><span>  WORD    SegGs;
</span></span><span style="display:flex;"><span>  WORD    SegSs;
</span></span><span style="display:flex;"><span>  DWORD   EFlags;
</span></span><span style="display:flex;"><span>  DWORD64 Dr0; <span style="color:#6272a4">// Hardware Breakpoint 1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  DWORD64 Dr1; <span style="color:#6272a4">// Hardware Breakpoint 2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  DWORD64 Dr2; <span style="color:#6272a4">// Hardware Breakpoint 3
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  DWORD64 Dr3; <span style="color:#6272a4">// Hardware Breakpoint 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  DWORD64 Dr6;
</span></span><span style="display:flex;"><span>  DWORD64 Dr7;
</span></span><span style="display:flex;"><span>  DWORD64 Rax;
</span></span><span style="display:flex;"><span>  DWORD64 Rcx;
</span></span><span style="display:flex;"><span>  DWORD64 Rdx;
</span></span><span style="display:flex;"><span>  DWORD64 Rbx;
</span></span><span style="display:flex;"><span>  DWORD64 Rsp;
</span></span><span style="display:flex;"><span>  DWORD64 Rbp;
</span></span><span style="display:flex;"><span>  DWORD64 Rsi;
</span></span><span style="display:flex;"><span>  DWORD64 Rdi;
</span></span><span style="display:flex;"><span>  DWORD64 R8;
</span></span><span style="display:flex;"><span>  DWORD64 R9;
</span></span><span style="display:flex;"><span>  DWORD64 R10;
</span></span><span style="display:flex;"><span>  DWORD64 R11;
</span></span><span style="display:flex;"><span>  DWORD64 R12;
</span></span><span style="display:flex;"><span>  DWORD64 R13;
</span></span><span style="display:flex;"><span>  DWORD64 R14;
</span></span><span style="display:flex;"><span>  DWORD64 R15;
</span></span><span style="display:flex;"><span>  DWORD64 Rip;
</span></span><span style="display:flex;"><span>  .
</span></span><span style="display:flex;"><span>  .
</span></span><span style="display:flex;"><span>  .
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// trimmed at the end
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} CONTEXT, <span style="color:#ff79c6">*</span>PCONTEXT;
</span></span></code></pre></div><p>Due to the fact that hardware breakpoints are not typically checked within malware, and since the condition of break can also be read or write or execute. It is often use in unpacking malwares by reverse engineers and malware analysts.</p>
<p>Again, this sort of check can also be detected if you retrieve the context of the CPU. This is where we have our little trick. As you might already know several APIs are hooked and monitored to detect malicious properties of a process. This also includes winAPIs that could be used to retrieve the context of the CPU. To avoid this detection, we can leverage the exception handler routine. This allows us to safely read and detect if a hardware breakpoint is checked.</p>
<p>This is how you do that,</p>
<ol>
<li>Step one is to generate an exception that can be handled, this can be anywhere within your code. One neat trick to add is to execute this code even before the start of the main function, like the TLS callback functions.</li>
<li>Step two, is to register the handler and handle the intentionally generated exception, this allows us to retrieve the context of the CPU.</li>
<li>Step three, is to simply check the hardware breakpoint registers to see if they are in use. If they are you can either jump to exit or jump to an alternate code path that will throw off the analyst.</li>
</ol>
<p>Lets see it in action here,</p>
<p>Step one, as mentioned before we can use an intentional exception generating scenario, like division by zero exception.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%205.png"  width="732" height="218" />
  
  
</figure>
<p>Once that is implemented, you just need to register the handler and the callback function will contain the logic to check the contents of the context structure which you can see in the above screenshot.</p>
<p>As seen in the below screenshot, the handler function examines the registers of the context structure, namely the hardware breakpoint registers. If it is not <code>NULL</code> we can safely say there is a hardware breakpoint present in the address space of the process.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%206.png"  width="1754" height="424" />
  
  
</figure>
<p>And voila, using this simple check, we can see if the hardware breakpoints are set or not.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%207.png"  width="1731" height="388" />
  
  
</figure>
<p>As you can see in the below screenshot, if the hardware breakpoint is set, the process is able to detect it.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%208.png"  width="1125" height="308" />
  
  
</figure>
<h3 id="jump-where--direct-rip-modification">Jump where ? Direct RIP modification</h3>
<p>Well, now that we have one modification of read, why not try writing into the context ? Since, we have access to the context structure, we can directly modify the contents of the RIP register to point wherever we want to, this means we can do indirect calls.</p>
<h4 id="1---jump-anywhere">#1 - Jump anywhere</h4>
<p>We can modify the RIP to jump to a location where we want using exception routines, it can be in middle of a function, start of a function, to a random shellcode, or even additional two bytes further in memory.</p>
<p>The first step to perform is to of course generate an exception, register a handler for it, and then retrieve the context.</p>
<p>Once that is out of the way, we can proceed to modifying RIP to be overwritten with the address of the function we want to call. Which otherwise will not get called.</p>
<p>In order to do that, we first need to know the address of the function that is loaded into the memory, if we know that we can safely jump to that location.</p>
<p>In the below piece of code, we find the offset to the function we want to call <code>myHiddenFunction()</code> which is <code>0x1000</code> . Then we retrieve the base address to the current process using the winAPI <code>GetModuleHandleA</code>  with the argument <code>NULL</code> . Once we know that, we add the offset of the function we want to call to the base address of our loaded process retrieving the address where the function was loaded in memory. We then proceed to overwriting the RIP with that address and continue the execution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ULONG64 myHiddenFunction_Offset <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1000</span>;
</span></span><span style="display:flex;"><span>HMODULE BaseAddress <span style="color:#ff79c6">=</span> GetModuleHandleA(<span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>printf(<span style="color:#f1fa8c">&#34;[*] Base Address of our process: %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, (ULONG64)BaseAddress);
</span></span><span style="display:flex;"><span>ULONG64 myHiddenFunctionAddress <span style="color:#ff79c6">=</span> (ULONG64)BaseAddress <span style="color:#ff79c6">+</span> myHiddenFunction_Offset;
</span></span><span style="display:flex;"><span>printf(<span style="color:#f1fa8c">&#34;[*] Address of myHiddenFunction: %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, (ULONG64)myHiddenFunctionAddress);
</span></span><span style="display:flex;"><span>ExceptionInfo<span style="color:#ff79c6">-&gt;</span>ContextRecord<span style="color:#ff79c6">-&gt;</span>Rip <span style="color:#ff79c6">=</span> (DWORD64)myHiddenFunctionAddress;
</span></span><span style="display:flex;"><span>printf(<span style="color:#f1fa8c">&#34;[*] RIP modified to address of myHiddenFunction: %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, ExceptionInfo<span style="color:#ff79c6">-&gt;</span>ContextRecord<span style="color:#ff79c6">-&gt;</span>Rip);
</span></span></code></pre></div><p>As you can see in the below screenshot, the function is called although no direct calling of the function exists within the process.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%209.png"  width="1182" height="383" />
  
  
</figure>
<h4 id="2---code-decryption-during-runtime">#2 - Code decryption during runtime</h4>
<p>Code decryption is a necessary technique when devising offensive toolkit, usually to get a second stage out there, execute a shellcode, or perhaps even self-modifying pieces of art. Since we have access to RIP, we can easily perform this technique without tripping off a lot of wires.</p>
<p>In this section I will be using a sample shellcode found from here,  <a href="https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12">MessageBox() shellcode</a>. This sample shellcode executes a simple “Hello World” text within a message box. To perform this PoC, I encrypt the shellcode with the XOR key <code>0x13</code> .</p>
<p>The idea is to use the exception <code>EXCEPTION_ACCESS_VIOLATION</code> which is generated whenever a invalid memory page or invalid access rights to a memory page is accessed. Since this shellcode is encrypted and stored in a global variable, I can easily generate the exception by simply casting the variable to a function call and calling it. This generates the exception we require because the global variable where the shellcode is stored in is not an executable memory region.</p>
<p>We can see that in the below screenshot.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2010.png"  width="1195" height="583" />
  
  
</figure>
<p>Now we modify the code to include two actions,</p>
<ul>
<li>Use the winAPI <code>VirtualProtect</code> to convert the global variable to an executable region using the parameter <code>PAGE_EXECUTE</code></li>
<li>Decrypt the shellcode using the XOR key <code>0x13</code> to produce a valid shellcode</li>
</ul>
<p>You can see that the change in the below source produced the message box.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2011.png"  width="1225" height="585" />
  
  
</figure>
<p>To introduce a self modifying aspect here, we can encrypt bytes within the program using a key previously known. And once an exception is generated while trying to execute them (or we generate one ourselves), we can simply change the permission of the page to modify the shellcode using the RIP register, turn it back to executable and continue execution.</p>
<p>This can also be used to perform an advanced decryption method where the shellcode is decrypted and executed instruction by instruction. This can be done using the <code>STATUS_SINGLE_STEP</code> exception and the <code>STATUS_ACCESS_VIOLATION</code> exception. This is given as a challenge for the reader to perform ;)</p>
<h4 id="3---indirect-syscall">#3 - Indirect syscall</h4>
<p>Similar to the possibilities mentioned above, we can also modify the RIP to overwrite it with an address within the <code>ntdll.dll</code> library to perform an indirect syscall.</p>
<p>One technique that is most commonly used within the malware domain is to use windows syscalls that is used to circumvent any hooking mechanism that might have been placed by the EDR within the general functions used in <code>ntdll.dll</code> . This is a common detection mechanism by an AV/EDR.</p>
<p>Although, the usage of syscall works to bypass the detection, this results in another possible detection mechanism. Using syscalls within your own process without any redirection to another library is called direct syscall technique, whereas invoking syscalls from the library <code>ntdll.dll</code> of the process is called an indirect syscall technique.</p>
<p>When using syscalls within your own program, it can usually get caught either by simple signature, assuming you bypassed that, it can be caught be checking the origin of the syscall. Typical origin of the syscall takes place via legitimate sources like the <code>ntdll.dll</code> itself, but when that is not the case, it spins up a major red flag. This can be avoided using, well you guessed it ! Vectored Exception Handling !!</p>
<p>As mentioned in this blog post, <a href="https://redops.at/en/blog/syscalls-via-vectored-exception-handling">“Syscalls via Vectored Exception Handling”</a>, this technique also provides a very legitimate looking call stack when analyzing. This is helps in reducing the detection possibility by a huge margin.</p>
<p>To brief up a little bit, syscalls are a piece of instruction that is responsible to switch the context from user-mode to kernel-mode. Many of the functions that are used within any process finally is a single or a combination of syscalls that is usually found within the <code>ntdll.dll</code> . This dll contains the final wrapper for several of the system calls used.</p>
<p>The syscalls are controlled by register RAX, which contains something called SSN, System Service Numbers. These are unique identifiers that are used to switch the control to the responsible code part within the kernel-land. SSN numbers in WIndows versions changes very frequently, it is very hard to keep track of them all. Although, there exists tools such as <a href="https://github.com/klezVirus/SysWhispers3">Syswhispers3</a> and websites such as <a href="https://j00ru.vexillium.org/syscalls/nt/64/">Windows Syscall Table</a> that can be used to retrieve the syscall for the particular version of windows you are using.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2012.png"  width="1827" height="433" />
  
  
</figure>
<p>VEH helps us by changing the control flow of the current process to the location that we want by allowing us to overwrite RIP, and also since it has access to literally the entire CPU context, we can use that in order to pass parameters. So combining both these ideas we could generate an exception and pass the necessary parameters within the registers in order to call the syscall that we want.</p>
<p>As mentioned in the above tagged blog post, the easiest way to do that is to leverage the exception <code>STATUS_ACCESS_VIOLATION</code> which is generated when invalid access to memory is performed. We can store the SSN number that we want to call, in this case <code>0x18</code> which corresponds to the syscall <code>NtAllocateVirtualMemory</code> , within a variable and then cast it to a function and call it. In essence this calls a function at the address <code>0x18</code> which obviously is not going to be a valid address. This in turn generates an exception of <code>STATUS_ACCESS_VIOLATION</code>. Now to pass the parameters to the function, we simply call the variable where the SSN is stored as any other function call and the context will contain the arguments you passed.</p>
<p>Once the exception is generated you can emulate the syscall instruction as how it is found within the <code>ntdll.dll</code> and change the control flow to the syscall address within the dll.</p>
<p>As mentioned above, you can see in the below screenshot that I am storing the SSN number into a variable, and then casting it to a function call and invoking it with the necessary arguments.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2013.png"  width="1142" height="407" />
  
  
</figure>
<p>Although, how do we find where the syscall is stored, what is the address of it ? The solution to this is basic signature matching (if you want stability) or offset calculation. Just like how we used offset calculation in changing to a function that we want to in one of the above examples, we can find the offset of the syscall opcode within the dll and then add the base address to it retrieving back the original address.</p>
<p>This is not stable across versions, so a better method to deal with it is to perform signature matching against the dll to find the opcodes that we want, in this case the <code>syscalll; ret</code> opcode.</p>
<p>In the below screenshot, we can notice that we retrieve back the address of the function <code>NtDrawText</code> as mentioned in the blog post, although we can retrieve any function, it does not matter as what we want to find is the address of the opcodes. Once the function address is retrieved, it is used as a starting point to perform signature matching against the given opcodes, <code>0xf, 0x5, 0xc3</code> . Once the syscall opcodes are found the address is sent back to be used.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2014.png"  width="902" height="536" />
  
  
</figure>
<p>Since the invalid access will be handled within our function, the RIP register will contain the SSN we require to call as well, the RIP will be stored with the address of the syscall we retrieved, and the RAX register the SSN.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2015.png"  width="907" height="388" />
  
  
</figure>
<p>After continuing the execution we can see that the syscall is executed and that the return value is a success as seen in the below screenshot.</p>





<figure class='flex justify-center mb-5'>
  <img src="/posts/seh_veh_security_perspective/Untitled%2016.png"  width="1356" height="533" />
  
  
</figure>
<p>Please give the mentioned blogpost a read in order to dive deeper into how this concept works. This method can be used in combination of several other methods in order to evade defenses, creativity is the only limit here.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this blog post, I have tried to explain some of the concept used in SEH and VEH programming that I have came across while performing malware analysis, playing CTFs, etc. There definitely exists a lot more tricks than the mentioned and if one is creative enough, further more can be found out as this is still an uncharted territory. This hopefully serves as a blog post that touches some light on this subject and gives the reader something to take away.</p>
<p>As a future work that I have not covered in this blog post are, how to use VEH as a debugger (used in cheatengine), using VEH to bypass protections and memory scanners, etc.</p>
<p>Thanks for reading this post, and please let me know your feedback through my contacts, any and all feedback helps ! Feel free to DM me if you would like to have further discussions on this topic too!</p>
<p>Stay tuned for more and have a great day !</p>
<p>Contact: <a href="https://twitter.com/amun_rha">Twitter</a> | <a href="https://linkedin.com/in/adhithyasureshk">LinkedIn</a></p>
<p>All the codes used in this post has been uploaded over here: <a href="https://github.com/AmunRha/BlogMaterials/tree/main/SEH_VEH_in_Malwares">Link to Github</a></p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://redops.at/en/blog/syscalls-via-vectored-exception-handling">https://redops.at/en/blog/syscalls-via-vectored-exception-handling</a></li>
<li><a href="https://revers.engineering/applied-re-exceptions/">https://revers.engineering/applied-re-exceptions/</a></li>
<li><a href="https://www.osronline.com/article.cfm%5Earticle=469.htm">https://www.osronline.com/article.cfm^article=469.htm</a></li>
<li><a href="https://limbioliong.wordpress.com/2022/01/09/understanding-windows-structured-exception-handling-part-1/">https://limbioliong.wordpress.com/2022/01/09/understanding-windows-structured-exception-handling-part-1/</a></li>
<li><a href="https://j00ru.vexillium.org/syscalls/nt/64/">https://j00ru.vexillium.org/syscalls/nt/64/</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record</a></li>
<li><a href="https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_REGISTRATION_RECORD.html">https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_REGISTRATION_RECORD.html</a></li>
<li><a href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.10240.0/shared/ntdef.h">https://github.com/tpn/winsdk-10/blob/master/Include/10.0.10240.0/shared/ntdef.h</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_pointers">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_pointers</a></li>
</ul>
</section>

  
    
  

    
  


  <footer>
    
      <div class="pb-14 taxonomy-list tags-list">
      
        <a href="/tags/seh/" alt="SEH">
          SEH
        </a>
      
        <a href="/tags/veh/" alt="VEH">
          VEH
        </a>
      
        <a href="/tags/exceptions/" alt="Exceptions">
          Exceptions
        </a>
      
        <a href="/tags/malware/" alt="Malware">
          Malware
        </a>
      
        <a href="/tags/redteaming/" alt="RedTeaming">
          RedTeaming
        </a>
      
        <a href="/tags/windows/" alt="Windows">
          Windows
        </a>
      
      </div>
    
  </footer>
</article>


  </main><footer class="pt-5 pb-10 grid gap-3 sm:grid-cols-2">
    <div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">
  © 2024 —
  <a href="http://localhost:1313/">AmunRha&#39;s Blog</a> 
  <span class="font-normal">with</span>
  <a
    href="https://github.com/nixentric/Lowkey-Hugo-Theme"
    target="_blank"
    rel="noopener noreferrer"
  >
    Lowkey
  </a>
</div>

    <div class="order-1 sm:order-2">
  <ul class="flex sm:justify-end gap-5">
    
    
    <li>    
      <a href="https://twitter.com/amun_rha" target="_blank" rel="noopener noreferrer">Twitter</a>
    </li>
    
    <li>    
      <a href="https://linkedin.com/in/adhithyasureshk" target="_blank" rel="noopener noreferrer">LinkedIn</a>
    </li>
    
    <li>    
      <a href="https://github.com/AmunRha" target="_blank" rel="noopener noreferrer">GitHub</a>
    </li>
    
    
  </ul>
</div>

</footer>
<button
  type="button"
  data-twe-ripple-init
  data-twe-ripple-color="light"
  class="!fixed bottom-5 end-5 hidden rounded-md bg-rose-500 p-3 text-xs font-medium uppercase leading-tight text-white shadow-md transition duration-150 ease-in-out hover:bg-rose-500 hover:shadow-lg focus:bg-rose-500 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-rose-500 active:shadow-lg"
  id="btn-back-to-top"
>
  <span class="[&>svg]:w-4">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="3"
      stroke="currentColor"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M4.5 10.5 12 3m0 0 7.5 7.5M12 3v18"
      />
    </svg>
  </span>
</button>

<script defer>
  const mybutton = document.getElementById('btn-back-to-top');
  const scrollFunction = () => {
    if (
      document.body.scrollTop > 20 ||
      document.documentElement.scrollTop > 20
    ) {
      mybutton.classList.remove('hidden');
    } else {
      mybutton.classList.add('hidden');
    }
  };
  const backToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  mybutton.addEventListener('click', backToTop);
  window.addEventListener('scroll', scrollFunction);
</script>
</body>

</html>